#bashar masalha - 324923689

# buffer-overflow-0 (Binary Exploitation)

## Challenge Description
Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.
Additional details will be available after launching your challenge instance.

Hints:
How can you trigger the flag to print?
If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.
Run man gets and read the BUGS section. How many characters can the program really read?



The program uses `gets()` and `strcpy()` unsafely on fixed-size buffers, allowing a buffer overflow.
If we overflow the buffer in `vuln()` enough to crash the program (by overwriting the return address), it triggers a signal handler that prints the flag.

The Files we got: vuln and vuln.c


## Steps

1. Analyzed the source code (`vuln.c`):
   - `buf2[16]` is overflowed via `strcpy`
   - `gets()` reads unchecked input into `buf1`
   - On `SIGSEGV`, the handler prints the flag

2. Locally tested:
   ```bash
   python3 -c "print('A'*60)" | ./vuln

The output: DEBUG_FLAG{test_flag}

python3 -c "print('A'*60)" | nc saturn.picoctf.net 57045

and we got the flag  : Input: picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}



in summery:

To solve the picoCTF “buffer-overflow-0” challenge,
we analyzed a C program that uses unsafe functions (gets and strcpy) to copy user input into a small buffer (buf2[16]),
making it vulnerable to a buffer overflow. We discovered that overflowing this buffer and causing a crash (segmentation fault) would trigger a signal handler that prints the flag.
After downloading the binary and source code, we tested locally by sending 60 'A's as input to cause the crash and verified the behavior with a dummy flag.txt file. 
Once confirmed, we sent the same payload to the remote server using nc, which triggered the overflow and revealed the real flag.
